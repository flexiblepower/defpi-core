{"version":3,"sources":["../../src/Utils/PromisesResolver.js"],"names":[],"mappings":";;;;;;;;;;IACM,gBAAgB;aAAhB,gBAAgB;8BAAhB,gBAAgB;;;iBAAhB,gBAAgB;;eACN,eAAC,KAAK,EAAE;AAChB,mBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAK;AAC5B,uBAAO,CAAC,KAAK,CAAC,CAAC;aAClB,CAAC,CAAC;SACN;;;eAEmB,uBAAC,QAAQ,EAAE;AAC3B,gBAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;AAC1B,sBAAM,KAAK,CAAC,oDAAoD,CAAC,CAAC;aACrE;;AAED,mBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAK;AACpC,oBAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AACvB,2BAAO,OAAO,CAAC,EAAE,CAAC,CAAC;iBACtB;;AAED,oBAAI,MAAM,GAAG,EAAE;oBACX,OAAO,GAAG,EAAE,CAAC;;AAEjB,wBAAQ,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,GAAG,EAAK;AAC/B,0BAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;iBACvB,CAAC,CAAC;;AAEH,wBAAQ,CAAC,OAAO,CAAC,UAAC,OAAO,EAAE,GAAG,EAAK;AAC/B,6BAAS,YAAY,CAAC,MAAM,EAAE;AAC1B,8BAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;AACnB,+BAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;AACtB,6BAAK,IAAI,CAAC,IAAI,MAAM,EAAE;AAClB,gCAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;AACZ,uCAAO;6BACV;yBACJ;;AAED,+BAAO,CAAC,OAAO,CAAC,CAAC;qBACpB;;AAED,6BAAS,cAAc,CAAC,MAAM,EAAE;AAC5B,+BAAO,YAAY,CAAC,EAAC,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAC,CAAC,CAAC;qBAC5D;;AAED,6BAAS,YAAY,CAAC,MAAM,EAAE;AAC1B,+BAAO,YAAY,CAAC,EAAC,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAC,CAAC,CAAA;qBACxD;;;AAGD,2BAAO,CAAC,IAAI,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;iBAC9C,CAAC,CAAC;aACN,CAAC,CAAC;SACN;;;WAjDC,gBAAgB;;;qBAoDP,gBAAgB","file":"PromisesResolver.js","sourcesContent":["\nclass PromisesResolver {\n    static empty(value) {\n        return new Promise((resolve) => {\n            resolve(value);\n        });\n    }\n\n    static allEvenFailed(promises) {\n        if (!Array.isArray(promises)) {\n            throw Error('allEvenFailed can only handle an array of promises');\n        }\n\n        return new Promise((resolve, reject) => {\n            if (promises.length === 0) {\n                return resolve([]);\n            }\n\n            let states = [],\n                results = [];\n\n            promises.forEach((promise, key) => {\n                states[key] = false; // promises are not resolved by default\n            });\n\n            promises.forEach((promise, key) => {\n                function resolveState(result) {\n                    states[key] = true;\n                    results[key] = result; // result may be an error\n                    for (let i in states) {\n                        if (!states[i]) {\n                            return;\n                        }\n                    }\n\n                    resolve(results);\n                }\n\n                function resolveSuccess(result) {\n                    return resolveState({status: 'success', result: result});\n                }\n\n                function resolveError(result) {\n                    return resolveState({status: 'error', error: result})\n                }\n\n                // whether the promise ends with success or error, consider it done\n                promise.then(resolveSuccess, resolveError);\n            });\n        });\n    }\n}\n\nexport default PromisesResolver;\n"]}