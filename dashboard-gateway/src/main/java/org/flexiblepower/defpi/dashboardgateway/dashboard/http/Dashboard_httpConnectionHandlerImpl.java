package org.flexiblepower.defpi.dashboardgateway.dashboard.http;

/*-
 * #%L
 * dEF-Pi dashboard gateway
 * %%
 * Copyright (C) 2017 - 2018 Flexible Power Alliance Network
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Enumeration;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

import javax.annotation.Generated;
import javax.servlet.ServletInputStream;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.eclipse.jetty.server.Request;
import org.flexiblepower.defpi.dashboardgateway.DashboardGateway;
import org.flexiblepower.defpi.dashboardgateway.dashboard.http.proto.Dashboard_httpProto.HTTPRequest;
import org.flexiblepower.defpi.dashboardgateway.dashboard.http.proto.Dashboard_httpProto.HTTPRequest.Builder;
import org.flexiblepower.defpi.dashboardgateway.dashboard.http.proto.Dashboard_httpProto.HTTPRequest.Method;
import org.flexiblepower.defpi.dashboardgateway.dashboard.http.proto.Dashboard_httpProto.HTTPResponse;
import org.flexiblepower.service.Connection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.protobuf.ByteString;

/**
 * Dashboard_httpConnectionHandlerImpl
 *
 * File generated by org.flexiblepower.create-service-maven-plugin. NOTE: This
 * file is generated as a stub, and has to be implemented by the user.
 * Re-running the codegen plugin will not change the contents of this file.
 * Template by FAN, 2017
 *
 */
@Generated(value = "org.flexiblepower.plugin.servicegen", date = "Oct 9, 2017 8:45:27 PM")
public class Dashboard_httpConnectionHandlerImpl implements Dashboard_httpConnectionHandler {

    public static final Logger LOG = LoggerFactory.getLogger(Dashboard_httpConnectionHandlerImpl.class);

    private final Connection connection;
    private final DashboardGateway service;
    private final AtomicInteger requestIdGenerator = new AtomicInteger(0);
    private final Map<Integer, CompletableFuture<HTTPResponse>> responseList = new ConcurrentHashMap<>();
    private String username = null;

    /**
     * Auto-generated constructor for the ConnectionHandlers of the provided service
     *
     * @param service
     *            The service for which to handle the connections
     */
    public Dashboard_httpConnectionHandlerImpl(final Connection connection, final DashboardGateway service) {
        this.connection = connection;
        this.service = service;
        service.addDashboardConnection(this);
    }

    @Override
    public void handleHTTPResponseMessage(final HTTPResponse message) {
        final CompletableFuture<HTTPResponse> completableFuture = this.responseList.get(message.getId());
        if (completableFuture == null) {
            Dashboard_httpConnectionHandlerImpl.LOG
                    .error("Received HTTPResponse for unknown request id: " + message.getId());
        } else {
            completableFuture.complete(message);
        }
    }

    @Override
    public void onSuspend() {
        // TODO Auto-generated method stub

    }

    @Override
    public void resumeAfterSuspend() {
        // TODO Auto-generated method stub

    }

    @Override
    public void onInterrupt() {
        // TODO Auto-generated method stub

    }

    @Override
    public void resumeAfterInterrupt() {
        // TODO Auto-generated method stub
    }

    @Override
    public void terminated() {
        this.service.removeDashboardConnection(this);
    }

    public String getUsername() {
        if (this.username == null) {
            final String processId = this.connection.remoteProcessId();
            this.username = this.service.getUsernameForProcessId(processId);
            Dashboard_httpConnectionHandlerImpl.LOG.debug("Process " + processId + " belongs to user " + this.username);
        }
        return this.username;
    }

    @SuppressWarnings("unused")
    public void handle(final String target,
            final Request baseRequest,
            final HttpServletRequest request,
            final HttpServletResponse response) {
        // Create request
        final HTTPRequest httpRequest = this.createHttpRequest(request);
        final CompletableFuture<HTTPResponse> future = new CompletableFuture<>();
        this.responseList.put(httpRequest.getId(), future);

        try {
            this.connection.send(httpRequest);
        } catch (final IOException e) {
            Dashboard_httpConnectionHandlerImpl.LOG.error("Error sending request: " + e.getMessage());
            Dashboard_httpConnectionHandlerImpl.LOG.trace(e.getMessage(), e);
            Dashboard_httpConnectionHandlerImpl.writeHttpResponse(HTTPResponse.newBuilder()
                    .setId(httpRequest.getId())
                    .setStatus(500)
                    .setBody(ByteString.copyFrom("Error", Charset.defaultCharset()))
                    .build(), response);
            return;
        }

        // Wait and get response
        final HTTPResponse httpResponse = this.waitForResponse(httpRequest.getId());
        Dashboard_httpConnectionHandlerImpl.writeHttpResponse(httpResponse, response);
    }

    private HTTPResponse waitForResponse(final Integer requestId) {
        try {
            Dashboard_httpConnectionHandlerImpl.LOG.debug("Waiting for response");
            final HTTPResponse httpResponse = this.responseList.get(requestId).get(30, TimeUnit.SECONDS);
            this.responseList.remove(requestId);
            return httpResponse;
        } catch (final TimeoutException e) {
            Dashboard_httpConnectionHandlerImpl.LOG.debug("Gateway Timeout");
            return HTTPResponse.newBuilder()
                    .setId(requestId)
                    .setStatus(504)
                    .setBody(ByteString.copyFrom("Gateway timeout", Charset.defaultCharset()))
                    .build();
        } catch (InterruptedException | ExecutionException e) {
            Dashboard_httpConnectionHandlerImpl.LOG.error("Error while waiting for response", e);
            return HTTPResponse.newBuilder()
                    .setId(requestId)
                    .setStatus(500)
                    .setBody(ByteString.copyFrom("Error", Charset.defaultCharset()))
                    .build();
        }
    }

    private static void writeHttpResponse(final HTTPResponse httpResponse, final HttpServletResponse response) {
        // Status
        response.setStatus(httpResponse.getStatus());
        // Headers
        for (final Entry<String, String> e : httpResponse.getHeadersMap().entrySet()) {
            if (!e.getKey().equals("WWW-Authenticate")) {
                response.setHeader(e.getKey(), e.getValue());
            }
        }
        // Body
        try (final ServletOutputStream outputStream = response.getOutputStream()) {
            IOUtils.write(httpResponse.getBody().toByteArray(), outputStream);
        } catch (final IOException e) {
            Dashboard_httpConnectionHandlerImpl.LOG.warn("Could not write HTTP response body", e);
        }
    }

    private HTTPRequest createHttpRequest(final HttpServletRequest request) {
        final Builder b = HTTPRequest.newBuilder();
        // Id
        b.setId(this.requestIdGenerator.incrementAndGet());
        // Uri
        b.setUri(request.getRequestURI());
        // Headers
        final Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            final String key = headerNames.nextElement();
            if (!key.equals("Authorization")) {
                b.putHeaders(key, request.getHeader(key));
            }
        }
        // Method
        final String method = request.getMethod();
        if (method.equals("HEAD")) {
            b.setMethod(Method.HEAD);
        } else if (method.equals("POST")) {
            b.setMethod(Method.POST);
        } else if (method.equals("PUT")) {
            b.setMethod(Method.PUT);
        } else if (method.equals("DELETE")) {
            b.setMethod(Method.DELETE);
        } else if (method.equals("TRACE")) {
            b.setMethod(Method.TRACE);
        } else if (method.equals("OPTIONS")) {
            b.setMethod(Method.OPTIONS);
        } else if (method.equals("CONNECT")) {
            b.setMethod(Method.CONNECT);
        } else if (method.equals("PATCH")) {
            b.setMethod(Method.PATCH);
        } else {
            b.setMethod(Method.GET);
        }

        // Body
        try (final ServletInputStream is = request.getInputStream()) {
            b.setBodyBytes(ByteString.readFrom(is));
        } catch (final IOException e) {
            Dashboard_httpConnectionHandlerImpl.LOG.warn("Could not read HTTP request body", e);
        }
        return b.build();
    }

}
